#  Copyright (c) 2020.
#  Author: Rohit Suratekar, IIMCB
#
#  UTR Analysis and related statistics.

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from SecretColors import Palette
from matplotlib.collections import LineCollection
from matplotlib.patches import Patch
from scipy.cluster import hierarchy
from scipy.cluster.hierarchy import dendrogram
from sklearn.cluster import AgglomerativeClustering
from sklearn.decomposition import PCA

matplotlib.rc('font', family='IBM Plex Sans')
# matplotlib.rcParams['text.usetex'] = True

p = Palette()
BASE_FOLDER = "salmon_counts"
CONDITIONS = ["wt_hsf", "wt_mars", "wt_whole"]
COND_COLORS = [p.cyan(shade=50),
               p.magenta(shade=50),
               p.yellow(shade=30),
               p.gray(shade=50),
               p.blue(shade=30),
               p.red(shade=30)]
REPLICATES = 3
BACKGROUND_GRAY = 10


def get_raw_files():
    """
    Change this function according to your own file names. In this case,
    I have used Quant.sf file generated by the Salmon.
    """
    all_samples = []
    c = 0
    for name in CONDITIONS:
        for i in range(REPLICATES):
            all_samples.append(f"{BASE_FOLDER}/{name}_{i + 1}_quant.sf")
        c += 1
    return all_samples


def extract_expression(filenames: list):
    """
    Takes all mapped file names (in this case for Salmon) as an input and
    generates the pandas Dataframe where each column represent each sample
    while reach rows represent gene. Each cell is TPM value calculated by
    your program for given combination.

    If you are not using Salmon output files, just change the column names
    below.

    :param filenames: Names of all the input files
    :return: numpy arrays of all TPM values for given samples
    """

    # Change this if not using Salmon output files
    col = "TPM"  # Name of column where TPM values are
    name = "Name"  # Name of column where your gene names are
    all_dfs = []
    for f in filenames:
        df = pd.read_csv(f, sep="\t")
        df = df.set_index(name)
        df = df[[col]]
        df = df.rename(columns={col: f})
        all_dfs.append(df)
    df = pd.concat(all_dfs, axis=1, join="inner")
    return df.to_numpy()


def perform_pca(tpms):
    """
    Generates the PCA plots

    :param tpms: TPM array where columns are each samples and rows are genes
    """
    pca = PCA()
    pca.fit(tpms)
    var = pca.components_
    lc = []
    colors = []
    for con, col in zip(CONDITIONS, COND_COLORS):
        lc.append(Patch(label=con, color=col))
        for i in range(REPLICATES):
            colors.append(col)

    percentages = [round(x, 2) for x in pca.explained_variance_ratio_ * 100]
    plt.legend(handles=lc, loc=0)
    plt.scatter(var[0, :], var[1, :], color=colors, s=100)
    plt.xlabel(f"PC1: {percentages[0]} %")
    plt.ylabel(f"PC2: {percentages[1]} %")
    plt.gca().set_facecolor(p.gray(shade=BACKGROUND_GRAY))
    plt.grid(axis="both", ls=":", alpha=0.7)
    plt.tight_layout()
    plt.savefig("plot.png", dpi=300)
    plt.show()


def plot_dendrogram(model, **kwargs):
    # Create linkage matrix and then plot the dendrogram

    # create the counts of samples under each node
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack([model.children_, model.distances_,
                                      counts]).astype(float)

    labels = []
    for c in CONDITIONS:
        for i in range(REPLICATES):
            labels.append(f"{c}_{i + 1}")
    labels = np.asarray(labels)
    # Plot the corresponding dendrogram
    hierarchy.set_link_color_palette(COND_COLORS)
    dendrogram(linkage_matrix, **kwargs, labels=labels)


def hierarchical_clustering(tpms):
    """
    Generates the clustering and plots it dendogram. Change the clustering
    parameters according to your dataset.

    :param tpms: Numpy array of TMP values where columns are samples and
    rows are genes
    """

    clustering = AgglomerativeClustering(
        distance_threshold=0, n_clusters=None,
        affinity="manhattan",
        linkage="complete")
    model = clustering.fit(tpms.transpose())
    # fig = plt.figure(figsize=(8, 6))
    ax = plt.subplot(111)  # type: plt.Axes
    plot_dendrogram(model, truncate_mode=None, ax=ax,
                    orientation="right")
    plt.xlabel("Distance")
    for c in ax.get_children():
        if isinstance(c, LineCollection):
            c.set_linewidth(2)
    ax.set_facecolor(p.gray(shade=BACKGROUND_GRAY))
    plt.tight_layout()
    plt.savefig("plot.png", dpi=300)
    plt.show()


def plot_ma(filename: str):
    """
    Plots MA-Plot for given DESeq2 output file.

    If you are using some custom file, change the column names accordingly

    :param filename: Output file generated by DESeq2
    """
    normal_color = p.blue(shade=40)
    rejected_color = p.red(shade=0)
    color_col = "color"
    threshold = 0.05
    df = pd.read_csv(filename)
    df[color_col] = rejected_color
    df.loc[df['padj'] < threshold, color_col] = normal_color

    plt.scatter(df["baseMean"], df["log2FoldChange"],
                color=df[color_col], marker=".")
    plt.ylim(-10, 10)
    plt.xlim(-5000, 150000)
    plt.axhline(0, ls="--", color=p.black(), alpha=0.5)
    plt.gca().set_facecolor(p.gray(shade=BACKGROUND_GRAY))
    plt.annotate("Y Clip : (-10 to 10)\n X Clip (0 to 1.4x10$^5$)",
                 xy=(0.98, 0.05), xycoords="axes fraction",
                 ha="right", va="bottom", color=p.gray(shade=70))
    handles = [
        Patch(color=normal_color, label="padj < 0.05"),
        Patch(color=rejected_color, label="padj > 0.05"),
    ]
    plt.legend(handles=handles, loc=0,
               facecolor=p.gray(shade=BACKGROUND_GRAY),
               edgecolor=p.gray(shade=BACKGROUND_GRAY))

    plt.ylabel("Log2 Fold Change")
    plt.xlabel("BaseMean Counts", labelpad=7)
    plt.title("$mia40$ HSF vs $mia40$ Whole")
    plt.savefig("plot.png", dpi=300)
    plt.show()


def plot_box_whisker():
    """
    Statistics of Log2Fold values generated by DESeq2. Change the file
    names, label names and colors according to your study
    """

    # Output files generated by DESeq2
    samples = [
        "salmon_hsf_vs_whole.csv",
        "salmon_mars_vs_whole.csv",
        "salmon_ko_hsf_vs_ko_whole.csv",
        "salmon_ko_mars_vs_ko_whole.csv",
    ]

    # Labels you want to give
    labels = ["WT HSF/W", "WT MARS/W", "mia40 HSF/W", "mia40 MARS/W"]

    # Color for each file
    colors = [p.cyan, p.magenta, p.yellow, p.green_light]

    significant = []

    for i, s in enumerate(samples):
        df = pd.read_csv(f"deseq2/{s}")
        total = len(df)
        df = df[df["padj"] < 0.05]
        significant.append(len(df) * 100 / total)
        vl = plt.violinplot(df["log2FoldChange"],
                            points=1000,
                            showextrema=False,
                            quantiles=[0.25, 0.5, 0.75],
                            positions=[i])

        for v in vl:
            if v == "bodies":
                for b in vl[v]:
                    b.set_color(colors[i](shade=60))
            else:
                vl[v].set_color(colors[i](shade=80))

    for i in range(len(labels)):
        labels[i] = f"{labels[i]}\n(SS: {round(significant[i], 1)}%)"
    plt.xticks(range(len(labels)), labels)
    plt.grid(axis="both", ls=":", color=p.gray(shade=40))
    plt.gca().set_facecolor(p.gray(shade=BACKGROUND_GRAY))
    plt.ylabel("Log2 Fold Change")
    plt.annotate("Only for padj < 0.05\nY Clip (-10 to 10)",
                 xy=(1, 1.02),
                 color=p.gray(shade=80),
                 xycoords="axes fraction", ha="right",
                 va="bottom")
    plt.annotate("Quantile Marks\n25%, 50%, 75%",
                 color=p.gray(shade=80),
                 xy=(0.5, 0.95),
                 xycoords="axes fraction",
                 va="top",
                 bbox=dict(color=p.gray(shade=20), alpha=0.8),
                 ha="center")
    plt.ylim(-10, 10)
    plt.savefig("plot.png", dpi=300)
    plt.show()


def run():
    plot_box_whisker()
